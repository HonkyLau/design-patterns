## 设计原则为何如此重要？

# 设计模式
为什么要有设计模式？
设计模式的好处？
怎么去在工作中运行设计模块？
如果新需求来了，如何能少些代码，如何写改动更少，易于扩展的代码。
不要为代码添加基于猜测的、实际不需要的功能、如果不清楚一个系统是否需要这个模式，一般不需要急着实现它，在需要的时候重构即可。

# 分类
通过完成什么工作划分为创建型模式、结构型模式和行为型模式 3 种类型
1、创建型模式：作用于对象的创建，将对象的创建与使用分离。其中囊括了单例、原型、工厂方法、抽象工厂、建造者5 种创建型模式。
2、结构型模式：将类或对象按某种布局组成更大的结构，其中以代理、适配器、桥接、装饰、外观、享元、组合 7 种结构型模式为主。
3、行为型模式：作用于类或对象之间相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。主要包含了模板方法、策略、命令、职责链、状态、观察 
者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

## 包结构说明
- structure包是每个模式抽象的代码结构
- AbstractFactory 抽象工厂模式
- MethodFactory 工厂方法模式
- SimpleFactory 简单工厂模式
- Strategy 策略模式
- Singleton 单例模式
- Proxy 代理模式
- TemplateMethod 模版方法
- Decorator 装饰模式


## 代码说明
部分代码示例参照了一些源码里面的接口和类的设计，只为了说明该设计模式在源码中的体现，不关心细节以及接口设计的完整性。
采用Java语言编码，本文档说描述的编程语言专业术语也是Java名称。

## 策略模式
在不同场景下需要使用不同的策略，就可以采用策略模式。定义一个上下文类，用于实现选择策略的逻辑。
比如商场的在不同节假日的打折活动（cashier代码）。可配合简单工厂模式生成上下文context的策略父类，或者提供切换策略的方式setXXX。
应用：spring resource

优势：
1. 扩展性强，将策略的具体实现放在子类中，再新增一种策略只需要增加一种具体的实现类；
2. 耦合性低，客户端只需要通过调用上下文context从而实现具体策略，而不需要关心具体实现的策略，从而实现客户端和具体策略的解耦。

## 简单工厂模式（静态工厂方法模式）
定义一个简单工厂类，用于实现将传入的参数生成工厂的实例。例如我是开一家甜品店，客户知道我这里可以做某种甜品，告诉我需要甜品名称，我就给他做好甜品。甜品店就是一个工厂，甜品就是产品。
简单工厂创建的对象比较少，工厂方法中的业务逻辑简单。

优势：
1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责；
2. 客户端无需知道所创建具体产品的类名，只需知道参数即可；
3. 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。

## 工厂方法模式
工厂方法是为每一个需要创建的对象配置了一个接口，通过接口生成对象。我们把对象比作产品，把工厂比作接口。
工厂方法解决的是专门的工厂给产品加工，做得是单一的业务。就比如皮鞋厂我就生产皮鞋，衣服，袜子沃克不制造。

优势：
1. 对比简单工厂，不需要修改简单工厂类，只需要修改客户端创建工厂的代码。
2. 适合创建对象多的情况。

## 抽象工厂模式
如果说工厂方法是解决如何生产不同分类的产品，比如不同厂家生产的手机。而抽象工厂解决如何生产不同产品族的问题，
比如厂家A生产手机和笔记本,厂家B也生产手机和笔记本。
在实际使用中，如果产品族是稳定的，用抽象工厂更适合，如果需要不断增加产品，抽象工厂类以及子类需要做修改，这样用工厂方法反而更好。

## 单例模式
一个类只能有一个实例，该类提供了获取实例的方法。单例模式实现需要保证private修饰构造函数，提供获取实例的静态方法。
单例模式分为饿汉式和懒汉式。饿汉式通过编译期间生成实例。懒汉式是第一个实例被需要时生成。

## 代理模式
当我们想访问操控某个对象时，而不直接访问，通过代理对象访问。在很多场景中使用到代理模式，比如远程调用代理，封装了协议层的细节，
提供简单易用的接口给使用者。比如远程代理，封装了真实对象的访问权限。
代理模式就像在使用者和真实对象之间增加一个中间层。

## 模版方法
模版这个词，就像小学读书老师在放学后留下的作业题，学生都抄将作业题抄在自己的作业本子上。老师写的作业题就是一个模版。
每个学生唯有回答的问题不一样。我们把老师写的作业题抽出来，答案在每个学生的作业本上，就是模版方法的思路。
模版方法将一个业务一个算法的框架搭建出来，而部分算法放在子类实现。
在代码中定义模版方法的抽象类，在类里面定义抽象的方法。
应用：future、mybatis动态代理

优势
1. 代码复用性强烈；
2. 主次清晰，实现者只需要关注最重要的部分；


## 装饰模式
装饰模式形成了一条对象链。比如从文件流生成了字节流。new BufferReader(new InputStreamReader(new FileInputStream(fileName))),看上去就像一个个对象形成的链条。
形成对象链是用在装饰抽象类定义了抽象对象变量，通过方法来赋值该对象变量。
实现类继承装饰抽象类，调用抽象类的行为方法完成对其他对象的装饰。
装饰模式的管道过滤器的设计思想， 通过一层层封装完成整条链路的任务。
应用：io流、akka(?)

## 原型模式
原型模式常用在需要生成大量对象时。原型模式分为浅拷贝和深拷贝。这两者的区别在于对象里面的对象是否指向同一个引用。浅拷贝
出来的对象，如果成员变量里面有对象，则拷贝出来的的对象指向被拷贝的对象的的成员变量。
深拷贝则反之，深拷贝的做法是在拷贝的时候单独拷贝变量，或者通过序列化写入写出对象。
应用：spring bean标签。

优势：
1. 隐藏了对象创建的细节；
2. 提高性能；

## 外观模式
外观模式也叫门面模式，提供了一个外观类，通过初始化生成了一些子系统实例（可以是类，模块），提供一致的方法来封装子系统行为。
常见的MVC三层架构也是使用了外观模式。每层通过定义抽象的接口提供给上一层。
外观模式常用在旧系统的重构上，通过一个外观类，将旧系统使用的细节封装成一个方法，提供给新系统。
新系统与外观类交互即可完成与老系统遗留代码所有复杂的工作。

## 建造者模式
建造者模式是创建型模式。该模式创建的对象有稳定的步骤。比如创建一个游戏里面的人物，人物需要有头、手、身体、脚。
创建人物的时候需要分步骤创建头、手、身体这些部位。
建造者的代码结构与外观模式容易混淆。（都是在一个类里面，引用其他类的行为）
建造者模式侧重对对象的创建，并且创建对象的构建顺序是稳定的，而外观类侧重与聚合多个子系统的行为，提供统一的界面。

优势：
1. 隐藏了创建对象的细节。

## 观察者模式
观察者模式又叫发布-订阅模式。常用在消息中间件中，比如rabbitmq、kafka。该模式定义了一个对象与多个对象的依赖关系。
多个对象订阅了主题对象的状态，当一个主题对象的状态发生改变时，会通知到多个对象。
《大话设计模式》里面描述将一个系统分割成一系列相互协作的类有一个副作用，就是需要维护对象的一致性。状态容易改变的主题类和需要被通知的类
就是一系类相互协作的类。主题类改变状态后需要去触发其他类执行相应的操作，这就是协作过程，被通知的类执行各自操作形成了一致性。
观察者模式将修改主题状态的部分和订阅主题的部分分开，解除了两个类、模块、系统的耦合性。

## 状态模式
状态模式常用在不同时刻需要切换对象的状态。状态强调的是一种有逻辑的变化，通常可以用UML的状态图表示。
如果在一个类的行为里面切换状态，这样需要用大量的ifelse去判断，状态模式定义了状态的抽象类，具体状态类通过继承抽象类来完成各种状态的切换，
去除了ifelse，提高了代码的可维护性。如果是状态种类不多，可以考虑用简单的ifelse实现。毕竟模式是为了减少工作量，过渡设计反而会适得其反。
状态模式的类图与策略模式类似，而状态模式的精髓在于体现状态改变，而策略模式是没有状态可言，是指根据不同场合切换需要算法。

## 备忘录模式
备忘录模式常用在撤销、保存功能中。通过新增与需要备份对象有相同变量的备份类，把备份的操作放在被备份的对象中，封装了
备份的细节，不影响客户端的功能。

## 桥接模式
桥接模式不是一个应对特定场景而产生的模式设计，而是针对代码设计的一个原则，它将组合/聚合设计原则体现的淋漓尽致。
一个设计原则，就像一把达斯克摩之剑悬在我们头上，每当我们开始动手写代码时，指导我们如何组织代码。
组合/聚合设计模式，将一个系统实现划分成不同维度的抽象，抽象之间存在聚合/组合的关系。
比如我们开发一款手机软件的时候，会考虑手机软件的分类，有通讯录、相册的功能，会考虑手机软件给不同品牌的手机兼容，手机品牌有M品牌、N品牌。
如果我们将顶层抽象类定义为手机软件，手机软件的实现类有通讯录软件，相册软件，通讯录软件的实现类又有手机M品牌定制的通讯录，手机N品牌定制的通讯录。
如果是这样的设计，增加一个手机品牌或者增加一款软件，则需要改动类和增加类，则违背了开放-封闭原则。
如果定义两个顶层接口，手机品牌和手机软件，手机品牌聚合手机软件，这样，如果增加一个新的手机品牌，只需要增加一个手机品牌的实现类。

## 命令模式
命令模式将发号施令的人与执行命令的人解耦开。通过声明执行操作的接口，与执行者关联。支持对请求排队，或记录请求日志，或可撤销操作。
特别注意的是，发布命令的人与执行操作之间需要负责执行命令的中间者。比如顾客点菜，通常是由服务员下单，这个服务员就是中间者。

## 职责链模式
职责链模式将对象形成一条链，使链上所有对象都有几乎去处理请求，从而将请求的发送者与接收者之间解耦。
请求沿着这条链，直到有职责处理该请求的对象处理它。
职责模式和装饰模式的类图相似。两个模式区别是，职责链模式强调的是对象的职责，而装饰模式是为了加强对象的功能。


### 参考资料
程杰的《大话设计模式》
https://www.jianshu.com/p/dfcdcd5d9ece
https://www.runoob.com/w3cnote/facade-pattern-3.html
https://blog.csdn.net/itguangit/article/details/107017632


