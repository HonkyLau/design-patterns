# 设计模式
为什么要有设计模式？
设计模式的好处？
怎么去在工作中运行设计模块？
带着一个思路去审视自己的代码，如果新需求来了，如何能少些代码，如何写改动更少，易于扩展的代码。

# 分类
通过完成什么工作划分为创建型模式、结构型模式和行为型模式 3 种类型
1、创建型模式：作用于对象的创建，将对象的创建与使用分离。其中囊括了单例、原型、工厂方法、抽象工厂、建造者5 种创建型模式。
2、结构型模式：将类或对象按某种布局组成更大的结构，其中以代理、适配器、桥接、装饰、外观、享元、组合 7 种结构型模式为主。
3、行为型模式：作用于类或对象之间相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。主要包含了模板方法、策略、命令、职责链、状态、观察 
 者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

## 包结构说明
- structure包是每个模式抽象的代码结构
- AbstractFactory 抽象工厂模式
- MethodFactory 工厂方法模式
- SimpleFactory 简单工厂模式
- Strategy 策略模式
- Singleton 单例模式
- Proxy 代理模式
- TemplateMethod 模版方法
- Decorator 装饰模式

## 代码说明
部分代码示例参照了一些源码里面的接口和类的设计，只为了说明该设计模式在源码中的体现，不关心细节以及接口设计的完整性。
采用Java语言编码，本文档说描述的编程语言专业术语也是Java名称。


## 策略模式
### 在不同场景下需要使用不同的策略，就可以采用策略模式。定义一个上下文类，用于实现选择策略的逻辑。
### 比如商场的在不同节假日的打折活动（cashier代码）。可配合简单工厂模式生成上下文context的策略父类，或者提供切换策略的方式setXXX。
优势：
1. 扩展性强，将策略的具体实现放在子类中，再新增一种策略只需要增加一种具体的实现类；
2. 耦合性低，客户端只需要通过调用上下文context从而实现具体策略，而不需要关心具体实现的策略，从而实现客户端和具体策略的解耦。

# 工厂篇
### 所有的工厂模式都是围绕如何创建对象的课题。

## 简单工厂模式（静态工厂方法模式）
### 定义一个简单工厂类，用于实现将传入的参数生成工厂的实例。例如我是开一家甜品店，客户知道我这里可以做某种甜品，告诉我需要甜品名称，我就给他做好甜品。甜品店就是一个工厂，甜品就是产品。
### 简单工厂创建的对象比较少，工厂方法中的业务逻辑简单。
优势：
1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责；
2. 客户端无需知道所创建具体产品的类名，只需知道参数即可；
3. 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。

## 工厂方法模式
### 工厂方法是为每一个需要创建的对象配置了一个接口，通过接口生成对象。我们把对象比作产品，把工厂比作接口。
### 工厂方法解决的是专门的工厂给产品加工，做得是单一的业务。就比如皮鞋厂我就生产皮鞋，衣服，袜子沃克不制造。
优势：
1. 对比简单工厂，不需要修改简单工厂类，只需要修改客户端创建工厂的代码。
2. 适合创建对象多的情况。

## 抽象工厂模式
### 如果说工厂方法是解决如何生产不同分类的产品，比如不同厂家生产的手机。而抽象工厂解决如何生产不同产品族的问题，
### 比如厂家A生产手机和笔记本,厂家B也生产手机和笔记本。
### 在实际使用中，如果产品族是稳定的，用抽象工厂更适合，如果需要不断增加产品，抽象工厂类以及子类需要做修改，这样用工厂方法反而更好。

## 单例模式
### 一个类只能有一个实例，该类提供了获取实例的方法。单例模式实现需要保证private修饰构造函数，提供获取实例的静态方法。
### 单例模式分为饿汉式和懒汉式。饿汉式通过编译期间生成实例。懒汉式是第一个实例被需要时生成。

## 代理模式
### 当我们想访问操控某个对象时，而不直接访问，通过代理对象访问。在很多场景中使用到代理模式，比如远程调用代理，封装了协议层的细节，
### 提供简单易用的接口给使用者。比如远程代理，封装了真实对象的访问权限。
### 代理模式就像在使用者和真实对象之间增加一个中间层。

## 模版方法
### 模版这个词，就像小学读书老师在放学后留下的作业题，学生都抄将作业题抄在自己的作业本子上。老师写的作业题就是一个模版。每个学生唯有回答的问题不一样。
### 我们把老师写的作业题抽出来，答案在每个学生的作业本上，就是模版方法的思路。
### 模版方法将一个业务一个算法的框架搭建出来，而部分算法放在子类实现。
### 在代码中定义模版方法的抽象类，在类里面定义抽象的方法。

优势
1. 代码复用性强烈；
2. 主次清晰，实现者只需要关注最重要的部分；


## 装饰模式
### 装饰模式形成了一条对象链。比如从文件流生成了字节流。new BufferReader(new InputStreamReader(new FileInputStream(fileName))),看上去就像一个个对象形成的链条。
### 形成对象链是用在装饰抽象类定义了抽象对象变量，通过方法来赋值该对象变量。
### 实现类继承装饰抽象类，调用抽象类的行为方法完成对其他对象的装饰。
### 装饰模式的管道过滤器的设计思想， 通过一层层封装完成整条链路的任务。


## 原型模式
原型模式常用在需要生成大量对象时。原型模式分为浅拷贝和深拷贝。这两者的区别在于对象里面的对象是否指向同一个引用。浅拷贝
出来的对象，如果成员变量里面有对象，则拷贝出来的的对象指向被拷贝的对象的的成员变量。
深拷贝则反之，深拷贝的做法是在拷贝的时候单独拷贝变量，或者通过序列化写入写出对象。
应用：spring bean标签。

优势：
1. 隐藏了对象创建的细节；
2. 提高性能；

## 外观模式
外观模式也叫门面模式，提供了一个外观类，通过初始化生成了一些子系统实例（可以是类，模块），提供一致的方法来封装子系统行为。
常见的MVC三层架构也是使用了外观模式。每层通过定义抽象的接口提供给上一层。
外观模式常用在旧系统的重构上，通过一个外观类，将旧系统使用的细节封装成一个方法，提供给新系统。
新系统与外观类交互即可完成与老系统遗留代码所有复杂的工作。

## 建造者模式
建造者模式是创建型模式。该模式创建的对象有稳定的步骤。比如创建一个游戏里面的人物，人物需要有头、手、身体、脚。
创建人物的时候需要分步骤创建头、手、身体这些部位。
建造者的代码结构与外观模式容易混淆。（都是在一个类里面，引用其他类的行为）
建造者模式侧重对对象的创建，并且创建对象的构建顺序是稳定的，而外观类侧重与聚合多个子系统的行为，提供统一的界面。
优势：
1. 隐藏了创建对象的细节。


